# ideas
f (x: Int): Int -> x * x

g (h: Function()) ->
    h()

g((x) -> x)

# main.fi
# "package" is a special name referring to the current package. It's the
# *only* way to access objects in the package.
import package
import from package: Type

main (argv: List<String>) ->
    i, arg <- argv
        t = Type.new(arg)
        print(i, t)

# lib/type.fi
Type ()
    "A type definition"

    @new (x) ->
        this.x = x

    meth (x) ->
        this.x + x

    # The $ prefix indicates a computed field (like @property in Python)
    $computed () ->
        result
        # alternatively, do some complex stuff and cache the result
        # this.computed = result

    $computed.set (value) ->
        this.computed = value

    + (x) ->
        this.x + x

# Package layout
#
# package.toml
#   name = "my_package"
#   version = "<version>"
#
# src/
#   api.fi  # Exported API accessed via `import my_package`
#   main.fi
#   lib/
#     type.fi
#
# dependencies/
#   package.toml
#   <name>/
#     src/
#       api.fi
#       main.fi
#     lib/
#       ...
#
# tests/
#   ...
