#!./target/release/feint
import system

# Exit with message
exit = (...) =>
    if $args.length > 0 ->
        print_err($args.join(" "))
    system.exit(1)


parse_args: List<Str> = (
    program_name: Str,
    argv: List<Str>,
    min_args: Int,
    max_args: Int | nil,
) =>
    "Parse args, such as `argv` from the command line.

    Args:
        program_name: The executable program name
        argv: The args that were passed on the command line
        min_args: The required minimum number of args
        max_args: The required maximum number of args

    "
    n_args = argv.length

    # NOTE: This version causes an error because the parenthesized
    #       expression followed by -> looks like a function.
    if n_args < min_args || (max_args !== nil && n_args > max_args) ->
        min_args_s = if min_args == 1 -> "" else -> "s"
        max_args_s = if max_args == 1 -> "" else -> "s"
        msg = if min_args == max_args ->
            $"requires exactly {min_args} arg{min_args_s}"
        else ->
            $"requires at least {min_args} arg{min_args_s} and no more
              than {max_args} args{max_args_s}"
        Err.new(ErrType.arg, $"{program_name} {msg}")
    else ->
        args = []
        i = 0
        loop i < argv.length ->
            args.push(argv.i)
            i += 1
        args


make_rule: Str = (...) =>
    "Make a horizontal rule that."
    count = 72 - 3 - ($args.length)
    count -= $args.map((str: Str) => str.length).sum
    "-".repeat(count)


$main = (...) =>
    p = print
    e = print_err

    args = parse_args("make-type", $args, 1, 2)

    if args.err ->
        exit(args.err)

    name = args.0
    repr = args.get(1)

    if name.err || repr.err ->
        if name.err -> e(name.err)
        if repr.err -> e(repr.err)
        exit()

    singleton_type_name = $"{name.upper()}_TYPE"
    type_name = $"{name}Type"
    obj_name = name

    rule = "-".repeat(80)
    e(rule)
    e($"Creating new type:\n")
    e($"singleton type name = {singleton_type_name}")
    e($"type name =  {type_name}")
    e($"object name = {obj_name}")
    e("\nAfter creation tasks:\n")
    e($"- Add `pub(crate) mod {name.lower()};` to types/mod.rs")
    e($"- Add constructor to types/new.rs")
    e($"- Add entry to `BUILTINS` in modules/builtins.rs")
    e($"- Add type-related methods in types/base.rs")
    e($"- Add Display and Debug impls in types/base.rs")
    e($"- Customize implementation")
    e($"- Handle in scanner/parser/compiler/VM")
    e(rule, "\n\n")

    template_file = File.new("./scripts/type.template")
    if template_file.err ->
        e(template_file.err)
        exit()

    template = template_file.text
    if template.err ->
        e(template.err)
        exit()

    output = template.render({
        "singleton_type_name": singleton_type_name,
        "type_name": type_name,
        "type_rule": make_rule(type_name, "type"),
        "obj_name": name,
        "obj_rule": make_rule(obj_name, "object"),
        "repr": repr,
    })

    if output.err ->
        e(output.err)
        exit()

    p(output)
