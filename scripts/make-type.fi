$main = (...) ->
    assert($args.len == 1)
    name = $args.0
    type_name = $"{name}Type"
    singleton_type_name = $"{name.upper()}_TYPE"

    print($"Creating new type: {name}")

    template = '
        use std::any::Any;
        use std::fmt;
        use std::sync::{Arc, RwLock};

        use once_cell::sync::Lazy;

        use crate::vm::RuntimeBoolResult;

        use super::gen;
        use super::new;

        use super::base::{ObjectRef, ObjectTrait, TypeRef, TypeTrait};
        use super::class::TYPE_TYPE;
        use super::ns::Namespace;

        // {name} Type ------------------------------------------------------------

        gen::type_and_impls!({type_name}, {name});

        pub static {singleton_type_name}: Lazy<new::obj_ref_t!({type_name})> =
            Lazy::new(|| new::obj_ref!({type_name}::new()));

        // {name} Object ----------------------------------------------------------

        pub struct {name} {
            ns: Namespace,
        }

        gen::standard_object_impls!({name});

        impl {name} {
            pub fn new() -> Self {
                Self { ns: Namespace::new() }
            }
        }

        impl ObjectTrait for {name} {
            gen::object_trait_header!({singleton_type_name});
        }

        // Display -------------------------------------------------------------

        impl fmt::Display for {name} {
            fn fmt(&self, f: &mut fmt::Formatter<\'_>) -> fmt::Result {
                write!(f, "nil")
            }
        }

        impl fmt::Debug for {name} {
            fn fmt(&self, f: &mut fmt::Formatter<\'_>) -> fmt::Result {
                write!(f, "{self}")
            }
        }
    '
