"Args module"

parse: Map = (
    program_name: Str,
    argv: List<Str>,
    spec: Map,
) =>
    "Parse args, such as `argv` from the command line.

    # Args

    - program_name: The executable program name
    - argv: The args that were passed on the command line
    - spec: The arg spec

    # Returns

    A Map containing args or errors.

    "
    help = spec.get("help")

    arg_specs = spec.get("args")
    option_specs = spec.get("options")
    flag_specs = spec.get("flags")

    args = []
    options = {}
    flags = {}

    errors = {}
    result = {}

    # This is used to avoid consuming values for flags.
    flag_names = []
    if flag_specs $! nil ->
        it = flag_specs.iter()
        loop (spec = it.next()) $! nil ->
            flag_names.push(spec.get("name"))

    # Extract args, options, and flags.
    it = argv.iter()
    loop (arg = it.next()) $! nil ->
        if arg.starts_with("--") ->
            name = arg.remove_prefix("--")
            is_inverse = name.starts_with("no-")

            name = name.replace("-", "_")
            maybe_val = it.peek()

            flag_name = if is_inverse -> name.remove_prefix("no_") else -> name
            flag_val = !is_inverse

            if maybe_val $$ nil || flag_names.has(flag_name) ->
                flags.add(flag_name, flag_val)
            # FIX: Boolean expressions don't short circuit.
            else if maybe_val.starts_with("--") ->
                flags.add(flag_name, flag_val)
            else ->
                options.add(name, maybe_val)
        else ->
            args.push(arg)

    # Map args
    if arg_specs $! nil ->
        i = 0
        it = arg_specs.iter()
        loop (spec = it.next()) $! nil ->
            name = spec.get("name")
            if i < args.length ->
                type = spec.get("type") ?? Str
                val = args.get(i)
                val = type.new(val)
                result.add(name, val)
            else ->
                default = spec.get("default")
                required = spec.get("required")
                match (default, required) ->
                    (nil, true) ->
                        errors.add(name, Err.new(ErrType.arg, $"Arg is required"))
                    * ->
                        result.add(name, default)
            i += 1

    # Map options
    if option_specs $! nil ->
        it = option_specs.iter()
        loop (spec = it.next()) $! nil ->
            name = spec.get("name")
            val = if options.has(name) ->
                type = spec.get("type") ?? Str
                val = options.get(name)
                type.new(val)
            else ->
                spec.get("default")
            result.add(name, val)

    # Map flags
    if flag_specs $! nil ->
        it = flag_specs.iter()
        loop (spec = it.next()) $! nil ->
            name = spec.get("name")
            val = match flags.get(name) ->
                true -> true
                false -> false
                nil -> false
            result.add(name, val)

    if errors.is_empty ->
        result
    else ->
        ess = if errors.length == 1 -> "" else -> "s"
        print_err($"{errors.length} error{ess} encountered while parsing args\n")
        argv.each((arg) => print_err(arg))
        errors.each((name, err) => print_err($"{name}: {err.message}"))
        Err.new(ErrType.arg, "")
